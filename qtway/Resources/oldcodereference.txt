wombatforensics class
----------------------
connect(isleuthkit, SIGNAL(UpdateStatus(int, int)), this, SLOT(UpdateProgress(int, int)), Qt::QueuedConnection);
connect(isleuthkit, SIGNAL(UpdateMessageTable()), this, SLOT(UpdateMessageTable()), Qt::QueuedConnection);
connect(isleuthkit, SIGNAL(ReturnImageNode(QStandardItem*)), this, SLOT(GetImageNode(QStandardItem*)), Qt::QueuedConnection);
connect(this, SIGNAL(LogVariable(WombatVariable*)), isleuthkit, SLOT(GetLogVariable(WombatVariable*)), Qt::QueuedConnection);
connect(isleuthkit, SIGNAL(LoadFileContents(QString)), this, SLOT(LoadFileContents(QString)), Qt::QueuedConnection);
connect(isleuthkit, SIGNAL(PopulateProgressWindow(WombatVariable*)), this, SLOT(PopulateProgressWindow(WombatVariable*)), Qt::QueuedConnection);
emit LogVariable(wombatvarptr);
/*
    wombatvarptr->visibleviewer = ReturnVisibleViewerID();
    // NEED TO DETERMINE WHICH VIEWER IS VISIBLE AND THEN LOAD THE RESPECITIVE DATA ACCORDINGLY.
    // QString imagename = wombatvarptr->evidencepath.split("/").last();
    QString tmptext = "";
    QString sigtext = "";
    tmptext = index.sibling(index.row(), 1).data().toString();
    if(tmptext != "")
    {
        wombatvarptr->evidenceobject.id = wombatdatabase->ReturnObjectEvidenceID(tmptext.toInt());
        QStringList currentevidencelist = wombatdatabase->ReturnEvidenceData(wombatvarptr->evidenceobject.id);
        wombatvarptr->evidencepath = currentevidencelist[0];
        wombatvarptr->evidenceobject.dbname = currentevidencelist[1];
        wombatvarptr->fileid = wombatdatabase->ReturnObjectFileID(tmptext.toInt());
        sigtext = index.sibling(index.row(), 4).data().toString(); // signature value which i need to compare to the xml of known values
        wombatvarptr->omnivalue = DetermineOmniView(sigtext);
        if(wombatvarptr->omnivalue == 0)
        {
            //ui->fileViewTabWidget->setTabEnabled(2, false); // where i disable the omni button 
        }
        else
        {
            ui->viewerstack->setCurrentIndex(wombatvarptr->omnivalue + 1);
            //ui->fileViewTabWidget->setTabEnabled(2, true); // where i enable the omni button*/
            /*if(omnivalue == 1)
                ui->viewerstack->setCurrentIndex(2);
            else if(omnivalue == 2)
                ui->viewerstack->setCurrentIndex(3);
            else if(omnivalue == 3)
                ui->viewerstack->setCurrentIndex(4);
                */
/*        }
    }
    else
    {
        tmptext = index.sibling(index.row(), 0).data().toString();
        QStringList evidenceobject.idlist = wombatdatabase->ReturnCaseActiveEvidenceID(wombatvarptr->caseobject.id);
        QStringList volumedesclist = isleuthkit->GetVolumeContents(wombatvarptr);
        for(int i=0; i < evidenceobject.idlist.count() / 3; i++)
        {
            if(tmptext.compare(evidenceobject.idlist[3*i+1].split("/").last()) == 0)
            {
                wombatvarptr->evidenceobject.id = evidenceobject.idlist[3*i].toInt();
                wombatvarptr->evidencepath = evidenceobject.idlist[3*i+1];
                wombatvarptr->evidenceobject.dbname = evidenceobject.idlist[3*i+2];
            }
        }
        // need to do other tmptext.compare's to see whether it's volume or fs...
        if(tmptext.compare(wombatvarptr->evidencepath.split("/").last()) == 0)
        {
            wombatvarptr->fileid = -1;
        }
        else // try one parent and see if it is a volume...
        {
            QString parenttext = index.parent().sibling(index.row(), 0).data().toString();
            for(int i=0; i < evidenceobject.idlist.count() / 3; i++)
            {
                if(parenttext.compare(evidenceobject.idlist[3*i+1].split("/").last()) == 0) // volume
                {
                    wombatvarptr->evidenceobject.id = evidenceobject.idlist[3*i].toInt();
                    wombatvarptr->evidencepath = evidenceobject.idlist[3*i+1];
                    wombatvarptr->evidenceobject.dbname = evidenceobject.idlist[3*i+2];
                }
            }
            fprintf(stderr, "evipath: %s\n", wombatvarptr->evidencepath.toStdString().c_str());
            bool isvolume = false;
            for(int i=0; i < volumedesclist.count() / 2; i++)
            {
                if(tmptext.compare(volumedesclist[i]) == 0)
                {
                    isvolume = true;
                    wombatvarptr->volid = volumedesclist[2*i+1].toInt();
                }
            }
            if(isvolume == true)
            {
                wombatvarptr->fileid = -2;
            }
            else // try a file system fileid = -3
            {
            }
        }
    }
    ThreadRunner* tmprun = new ThreadRunner(isleuthkit, "showfile", wombatvarptr);
    threadpool->start(tmprun);
    */
void WombatForensics::RemEvidence()
{
    /*
    wombatprogresswindow->ClearTableWidget();
    wombatvarptr->jobtype = 2; // remove evidence
    QStringList evidenceList;
    evidenceList.clear();
    // populate case list here
    //evidenceList = wombatdatabase->ReturnCaseActiveEvidence(wombatvarptr->caseobject.id);
    bool ok;
    QString item = QInputDialog::getItem(this, tr("Remove Existing Evidence"), tr("Select Evidence to Remove: "), evidenceList, 0, false, &ok);
    if(ok && !item.isEmpty()) // open selected case
    {
        //wombatvarptr->evidenceobject.id = wombatdatabase->ReturnEvidenceID(item);
        //wombatvarptr->jobid = wombatdatabase->InsertJob(wombatvarptr->jobtype, wombatvarptr->caseobject.id, wombatvarptr->evidenceobject.id);
        emit LogVariable(wombatvarptr);
        QString tmpstring = item.split("/").last() + " - " + QString::fromStdString(GetTime());
        QStringList tmplist;
        tmplist << tmpstring << QString::number(wombatvarptr->jobid);
        wombatprogresswindow->UpdateAnalysisTree(2, new QTreeWidgetItem(tmplist));
        wombatprogresswindow->UpdateFilesFound("");
        wombatprogresswindow->UpdateFilesProcessed("");
        wombatprogresswindow->UpdateAnalysisState("Removing Evidence");
        //LOGINFO("Removing Evidence Started");
        //wombatdatabase->InsertMsg(wombatvarptr->caseobject.id, wombatvarptr->evidenceobject.id, wombatvarptr->jobid, 2, "Removing Evidence Started");
        UpdateMessageTable();
        //wombatdatabase->RemoveEvidence(item);
        wombatprogresswindow->UpdateProgressBar(25);
        //QString tmppath = wombatvarptr->evidenceobject.dirpath + item.split("/").last() + ".db";
        //if(QFile::remove(tmppath))
        //{
        //}
        //else
            //emit DisplayError("2.1", "Evidence DB File was NOT Removed", "");
        wombatprogresswindow->UpdateProgressBar(50);
        UpdateCaseData();
        wombatprogresswindow->UpdateProgressBar(75);
        //LOGINFO("Removing Evidence Finished");
        //wombatdatabase->InsertMsg(wombatvarptr->caseobject.id, wombatvarptr->evidenceobject.id, wombatvarptr->jobid, 2, "Removing Evidence Finished");
        //wombatdatabase->UpdateJobEnd(wombatvarptr->jobid, 0, 0);
        UpdateMessageTable();
        wombatprogresswindow->UpdateAnalysisState("Removing Evidence Finished");
        wombatprogresswindow->UpdateProgressBar(100);
        UpdateMessageTable();
    }*/
}
-------------
interfaces.h
-------------
#ifndef INTERFACES_H
#define INTERFACES_H

#include <QtPlugin>
#include <QtCore>
#include <QVariant>
#include <QList>
#include <QMap>
//#include "progresswindow.h"
#include "wombatvariable.h"

class QStringList;
class QObject;
class QWidget;
class QStandardItem;

// might not need.
template <class T> class VPtr
{
public:
    static T* asPtr(QVariant v)
    {
        return  (T *) v.value<void *>();
    }
    static QVariant asQVariant(T* ptr)
    {
        return qVariantFromValue((void *) ptr);
    }
};
/*
class PluginInterface
{
public:
    virtual ~PluginInterface() {}

    Q_INVOKABLE virtual PluginMap Initialize(WombatVariable wombatvariable) = 0;
    Q_INVOKABLE virtual void Run(QString input) = 0;
    virtual void Finalize() = 0;
};
*/
class ViewerInterface
{
public:
    virtual ~ViewerInterface() {}

    virtual QList<ViewerMap> Initialize() = 0;
    virtual void Run(QString input) = 0;
    virtual void Finalize() = 0;
};
/*
class ListInterface
{
public:
    virtual ~ViewerInterface() {}

    virtual QVariantMap Initialize() = 0;
    virtual void Run(QString input) = 0;
    virtual void Finalize() = 0;
};
*/
/*
class BasicToolsInterface
{
public:
    virtual ~BasicToolsInterface() {}

    virtual QWidget* setupTypTab() = 0;
    virtual QWidget* setupDirTab() = 0;
    virtual QWidget* setupHexTab() = 0;
    virtual QWidget* setupTxtTab() = 0;
    virtual QStringList evidenceToolboxIcons() const = 0;
    virtual void LoadHexModel(QString tmpFilePath) = 0;
    virtual void LoadTxtContent(QString asciiText) = 0;
};
*/
class SleuthKitInterface
{
public:
    virtual ~SleuthKitInterface() {}

    virtual void Initialize(WombatVariable wombatVariable) = 0;
    //virtual void Run(QString input);
    //virtual void Finalize() {} = 0;
    virtual void SetupSystemProperties() = 0;
    virtual void SetupLog() = 0;
    virtual void OpenEvidence(WombatVariable wombatVariable) = 0;
    //virtual void SetupSystemProperties(QString settingsPath, QString configFilePath) = 0;
    //virtual void SetupSystemLog(QString dataPath, QString logFilePath, ProgressWindow* progressWindow, WombatVariable *wombatVariable) = 0;
    virtual QString SetupImageDatabase(QString imgDBPath, QString evidenceFilePath) = 0;
    virtual void OpenImageDatabase(QString imgDBPath, QString evidenceFilePath) = 0;
    virtual void SetupSystemBlackboard() = 0;
    //virtual void SetupSystemSchedulerQueue() = 0;
    //virtual void SetupSystemFileManager() = 0;
    virtual void SetupScheduler() = 0;
    virtual void SetupFileManager() = 0;
    //virtual void OpenEvidence(QString evidencePath, ProgressWindow* progressWindow) = 0;
    virtual void LogEntry(QString logMsg) = 0;
    virtual QStandardItem* GetCurrentImageDirectoryTree(QString imageDbPath, QString imageName) = 0;
    virtual QString GetFileContents(int fileID) = 0;
    virtual QString GetFileTxtContents(int fileID) = 0;

};

#define ViewerInterface_iid "wombat.ViewerInterface"
Q_DECLARE_INTERFACE(ViewerInterface, ViewerInterface_iid)

//#define PluginInterface_iid "wombat.PluginInterface"
//Q_DECLARE_INTERFACE(PluginInterface, PluginInterface_iid)

//#define EvidenceInterface_iid "wombat.EvidenceInterface"
//Q_DECLARE_INTERFACE(EvidenceInterface, EvidenceInterface_iid)

//#define BasicToolsInterface_iid "wombat.BasicToolsInterface"
//Q_DECLARE_INTERFACE(BasicToolsInterface, BasicToolsInterface_iid)

#define SleuthKitInterface_iid "wombat.SleuthKitInterface"
Q_DECLARE_INTERFACE(SleuthKitInterface, SleuthKitInterface_iid)

#endif
-------------
sluethkit.h
-------------
#ifndef SLEUTHKIT_H 
#define SLEUTHKIT_H

#include "wombatvariable.h"
#include "wombatdatabase.h"
#include <sqlite3.h>
#include "../sleuthkit/framework/tsk/framework/framework.h" // provides tsk framework
#include <time.h>
#include "TskLog.h"
#include <QtPlugin>
#include <QObject>
#include <QString>
#include <string>
#include <QStringList>
#include <QFile>
#include <QXmlStreamWriter>
#include <QStandardItemModel>
#include <QByteArray>
#include <QDataStream>
#include <QThreadPool>
#include <QtConcurrent>
#include <fstream>
#include <cstdio>

class SleuthKitPlugin : public QObject
{
    Q_OBJECT
    
public:
    SleuthKitPlugin(WombatDatabase* wombatcasedata);
    ~SleuthKitPlugin() {};
    //SleuthKit Interface Functions
    Q_INVOKABLE void Initialize(WombatVariable* wombatVariable);
    void SetupSystemProperties();
    void SetupLog();
    void SetupScheduler();
    void SetupFileManager();
    void SetupBlackboard();
    void SetupImageDatabase();
    void SetEvidenceDB(WombatVariable* wombatVariable);
    Q_INVOKABLE void OpenEvidence(WombatVariable* wombatVariable);
    Q_INVOKABLE void RefreshTreeViews(WombatVariable* wombatVariable);
    Q_INVOKABLE void PopulateCase(WombatVariable* wombatVariable);
    Q_INVOKABLE void ShowFile(WombatVariable* wombatVariable);
    Q_INVOKABLE void ExportFiles(WombatVariable* wombatVariable);
    void SetupSystemBlackboard();
    void GetImageTree(WombatVariable* wombatvariable, int isAddEvidence);
    QString GetFileContents(int fileID);
    QString GetVolumeFilePath(WombatVariable* wombatVariable, int volID);
    QStringList GetVolumeContents(WombatVariable* wombatVariable);
    void ExportFile(std::string tmppath, int objectID);
    void TaskMap(TskSchedulerQueue::task_struct* &task);

private:
    //WombatVariable wombatvariable;
    WombatVariable* wombatvariable;
    WombatDatabase* wombatdata;
    TskSystemPropertiesImpl* systemproperties;
    TskFileManagerImpl* fileManager;
    TskLog* log;
    TskImgDBSqlite* initialdb;
    TskImgDBSqlite* imgdb;
    TskImgDBSqlite* tmpdb;
    TskSchedulerQueue scheduler;
    void FinishExport(int processcount);

public slots:
    void threadFinished(void);
    void GetLogVariable(WombatVariable* wvariable)
    {
        emit SetLogVariable(wvariable);
    };
signals:
    void UpdateStatus(int filecount, int processcount);
    void ReturnImageNode(QStandardItem* imagenode);
    void UpdateMessageTable(void);
    void SetLogVariable(WombatVariable* wvariable);
    void LoadFileContents(QString filepath);
    void PopulateProgressWindow(WombatVariable* wvariable);
};

class TaskRunner : public QObject, public QRunnable
{
    Q_OBJECT
public:
    TaskRunner(TskSchedulerQueue::task_struct* tmptask, TskPipeline* tmppipe)
    {
        task = tmptask;
        filepipeline = tmppipe;
    }
    void run()
    {
        try
        {
            fprintf(stderr, "task id: %i\n", (int)task->id);
            filepipeline->run(task->id);
        }
        catch(TskException &ex)
        {
            fprintf(stderr, "TskException: %s\n", ex.message().c_str());
        }
    }
private:
    TskSchedulerQueue::task_struct* task;
    TskPipeline* filepipeline;
};
#endif // SLEUTHKIT_H

------------------------
TskLog.h
------------------------
#ifndef TSKLOG_H
#define TSKLOG_H

#include <time.h>
#include "../../../../../main/wombatvariable.h"
#include "Log.h"
#include "../framework_i.h"
#include <sqlite3.h>
#include <string>
#include <iostream>
#include <fstream>
#include <QObject>

class TskLog : public QObject, public Log
{
    Q_OBJECT
public:

    TskLog(std::string datapath)
    {
        dbpath = datapath;
        dbpath.append("WombatLog.db");
    };
    virtual ~TskLog() 
    {
        Log::close();
    };

    void log(Channel msgType, const std::string &logMsg);
    void log(Channel msgType, const std::wstring &logMsg);
public slots:
    void LogVariable(WombatVariable* wombatVariable)
    {
        logvariable = *wombatVariable;
        //fprintf(stderr, "Log got the variable and it has a caseid of: %d\n", logvariable.caseid);
    };
protected:
    std::string logpath;
    std::string dbpath;
    std::ofstream outstream;
    int caseid;
    int imageid;
    int analysistype;
    WombatVariable logvariable;
};
#endif
-----------------
wombatdatabase.h
-----------------
    /*
    int InsertJob(int jobType, int caseID, int evidenceID);
    int InsertEvidence(QString evidenceName, QString evidenceFilePath, int caseID);
    int InsertObject(int caseid, int evidenceid, int itemtype, int curid);
    void InsertMsg(int caseid, int evidenceid, int jobid, int msgtype, const char* msg);
    void UpdateJobEnd(int jobid, int filecount, int processcount);
    QStringList ReturnJobDetails(int jobid);
    */
        /*
    QStringList ReturnCaseActiveEvidenceID(int caseid);
    int ReturnObjectFileID(int objectid);
    int ReturnObjectEvidenceID(int objectid);
    QStringList ReturnCaseActiveEvidence(int caseID);
    int ReturnJobCaseID(int jobid);
    int ReturnJobEvidenceID(int jobid);
    int ReturnObjectID(int caseid, int evidenceid, int fileid);
    int ReturnEvidenceID(QString evidencename);
    int ReturnEvidenceDeletedState(int evidenceid);
    QString ReturnEvidencePath(int evidenceid);
    void RemoveEvidence(QString evidencename);
    QStringList ReturnCaseEvidenceIdJobIdType(int caseid);
    QStringList ReturnMessageTableEntries(int jobid);
    QStringList ReturnEvidenceData(int evidenceid);
    */
-------------------
wombatdatabase.cpp
-------------------

// not used will eventually be deleted.
/*
int WombatDatabase::ReturnObjectFileID(int objectid)
{
    int fileid = 0;
    if(sqlite3_prepare_v2(wombatdb, "SELECT fileid FROM objects WHERE objectid = ?;", -1, &casestatement, NULL) == SQLITE_OK)
    {
        if(sqlite3_bind_int(casestatement, 1, objectid) == SQLITE_OK)
        {
            int ret = sqlite3_step(casestatement);
            if(ret == SQLITE_ROW || ret == SQLITE_DONE)
            {
                fileid = sqlite3_column_int(casestatement, 0);
            }
            else
                emit DisplayError("1.18", "RETURN OBJECT'S FILEID ", sqlite3_errmsg(wombatdb));
        }
        else
            emit DisplayError("1.18", "RETURN OBJECT'S FILEID ", sqlite3_errmsg(wombatdb));
    }
    else
        emit DisplayError("1.18", "RETURN OBJECT'S FILEID ", sqlite3_errmsg(wombatdb));

    return fileid;
}

int WombatDatabase::ReturnObjectEvidenceID(int objectid)
{
    int evidenceid = 0;
    if(sqlite3_prepare_v2(wombatdb, "SELECT evidenceid FROM objects WHERE objectid = ?;", -1, &casestatement, NULL) == SQLITE_OK)
    {
        if(sqlite3_bind_int(casestatement, 1, objectid) == SQLITE_OK)
        {
            int ret = sqlite3_step(casestatement);
            if(ret == SQLITE_ROW || ret == SQLITE_DONE)
                evidenceid = sqlite3_column_int(casestatement, 0);
            else
                emit DisplayError("1.20", "RETURN OBJECT EVIDENCEID ", sqlite3_errmsg(wombatdb));
        }
        else
            emit DisplayError("1.20", "RETURN OBJECT EVIDENCEID ", sqlite3_errmsg(wombatdb));
    }
    else
        emit DisplayError("1.20", "RETURN OBJECT EVIDENCEID ", sqlite3_errmsg(wombatdb));

    return evidenceid;
}

int WombatDatabase::ReturnObjectID(int caseid, int evidenceid, int fileid)
{
    int objectid = 0;
    if(sqlite3_prepare_v2(wombatdb, "SELECT objectid FROM objects WHERE caseid = ? AND evidenceid = ? AND fileid = ?;", -1, &casestatement, NULL) == SQLITE_OK)
    {
        if(sqlite3_bind_int(casestatement, 1, caseid) == SQLITE_OK && sqlite3_bind_int(casestatement, 2, evidenceid) == SQLITE_OK && sqlite3_bind_int(casestatement, 3, fileid) == SQLITE_OK)
        {
            int ret = sqlite3_step(casestatement);
            if(ret == SQLITE_ROW || ret == SQLITE_DONE)
                objectid = sqlite3_column_int(casestatement, 0);
            else
                emit DisplayError("1.19", "RETURN OBJECT ID ", sqlite3_errmsg(wombatdb));
        }
        else
            emit DisplayError("1.19", "RETURN OBJECT ID ", sqlite3_errmsg(wombatdb));
    }
    else
        emit DisplayError("1.19", "RETURN OBJECT ID ", sqlite3_errmsg(wombatdb));

    return objectid;
}

int WombatDatabase::InsertJob(int jobType, int caseID, int evidenceID)
{
    int jobid = 0;

    if(sqlite3_prepare_v2(wombatdb, "INSERT INTO job (type, caseid, evidenceid, start) VALUES(?, ?, ?, ?);", -1, &casestatement, NULL) == SQLITE_OK)
    {
        if(sqlite3_bind_int(casestatement, 1, jobType) == SQLITE_OK && sqlite3_bind_int(casestatement, 2, caseID) == SQLITE_OK && sqlite3_bind_int(casestatement, 3, evidenceID) == SQLITE_OK && sqlite3_bind_text(casestatement, 4, GetTime().c_str(), -1, SQLITE_TRANSIENT) == SQLITE_OK)
        {
            int ret = sqlite3_step(casestatement);
            if(ret == SQLITE_ROW || ret == SQLITE_DONE)
            {
                jobid = sqlite3_last_insert_rowid(wombatdb);
            }
            else
                emit DisplayError("1.4", "INSERT JOB ", sqlite3_errmsg(wombatdb));
        }
        else
            emit DisplayError("1.4", "INSERT JOB ", sqlite3_errmsg(wombatdb));
    }
    else
        emit DisplayError("1.4", "INSERT JOB ", sqlite3_errmsg(wombatdb));
    
    return jobid;
}

int WombatDatabase::InsertEvidence(QString evidenceName, QString evidenceFilePath, int caseID)
{
    int evidenceid = 0;
    if(sqlite3_prepare_v2(wombatdb, "INSERT INTO evidence (fullpath, name, caseid, creation, deleted) VALUES(?, ?, ?, ?, 0);", -1, &casestatement, NULL) == SQLITE_OK)
    {
        if(sqlite3_bind_text(casestatement, 1, evidenceFilePath.toStdString().c_str(), -1, SQLITE_TRANSIENT) == SQLITE_OK && sqlite3_bind_text(casestatement, 2, evidenceName.toStdString().c_str(), -1, SQLITE_TRANSIENT) == SQLITE_OK && sqlite3_bind_int(casestatement, 3, caseID) == SQLITE_OK && sqlite3_bind_text(casestatement, 4, GetTime().c_str(), -1, SQLITE_TRANSIENT) == SQLITE_OK)
        {
            int ret = sqlite3_step(casestatement);
            if(ret == SQLITE_ROW || ret == SQLITE_DONE)
            {
                // it was successful
                evidenceid = sqlite3_last_insert_rowid(wombatdb);
            }
            else
                emit DisplayError("1.7", "INSERT EVIDENCE INTO CASE", sqlite3_errmsg(wombatdb));
        }
        else
            emit DisplayError("1.7", "INSERT EVIDENCE INTO CASE", sqlite3_errmsg(wombatdb));
    }
    else
        emit DisplayError("1.7", "INSERT EVIDENCE INTO CASE", sqlite3_errmsg(wombatdb));

    return evidenceid;
}

int WombatDatabase::InsertObject(int caseid, int evidenceid, int itemtype, int curid)
{
    int objectid = 0;
    std::string tmpquery = "INSERT INTO objects (caseid, evidenceid, ";
    if(itemtype == 0) // item is file
        tmpquery += "fileid";
    else if(itemtype == 1) // item is partition
        tmpquery += "partid";
    else if(itemtype == 2) // item is a volume
        tmpquery += "volid";
    else if(itemtype == 3) // item is an image
        tmpquery += "imgid";
    tmpquery += ") VALUES(?, ?, ?);";
    if(sqlite3_prepare_v2(wombatdb, tmpquery.c_str(), -1, &casestatement, NULL) == SQLITE_OK)
    {
        if(sqlite3_bind_int(casestatement, 1, caseid) == SQLITE_OK && sqlite3_bind_int(casestatement, 2, evidenceid) == SQLITE_OK && sqlite3_bind_int(casestatement, 3, curid) == SQLITE_OK)
        {
            int ret = sqlite3_step(casestatement);
            if(ret == SQLITE_ROW || ret == SQLITE_DONE)
            {
                // it was successful
                objectid = sqlite3_last_insert_rowid(wombatdb);
            }
            else
               DisplayError("1.17", "INSERT OBJECT INTO CASE ", sqlite3_errmsg(wombatdb));
        }
        else
            DisplayError("1.17", "INSERT OBJECT INTO CASE ", sqlite3_errmsg(wombatdb));
    }
    else
        DisplayError("1.17", "INSERT OBJECT INTO CASE ", sqlite3_errmsg(wombatdb));

    return objectid;
}

QStringList WombatDatabase::ReturnCaseActiveEvidenceID(int caseID)
{
    QStringList tmpList;
    if(sqlite3_prepare_v2(wombatdb, "SELECT evidenceid,fullpath,name FROM evidence WHERE caseid = ? AND deleted = 0 ORDER BY evidenceid;", -1, &casestatement, NULL) == SQLITE_OK)
    {
        if(sqlite3_bind_int(casestatement, 1, caseID) == SQLITE_OK)
        {
            while(sqlite3_step(casestatement) == SQLITE_ROW)
            {
                tmpList << QString::number(sqlite3_column_int(casestatement, 0)) << (const char*)sqlite3_column_text(casestatement, 1) << (const char*)sqlite3_column_text(casestatement, 2);
            }
        }
        else
        {
            emit DisplayError("1.8", "RETURN CASE EVIDENCE", sqlite3_errmsg(wombatdb));
        }
    }
    else
        emit DisplayError("1.8", "RETURN CASE EVIDENCE", sqlite3_errmsg(wombatdb));

    return tmpList;
}

QStringList WombatDatabase::ReturnCaseActiveEvidence(int caseID)
{
    QStringList tmpList;
    if(sqlite3_prepare_v2(wombatdb, "SELECT fullpath FROM evidence WHERE caseid = ? AND deleted = 0 ORDER BY evidenceid;", -1, &casestatement, NULL) == SQLITE_OK)
    {
        if(sqlite3_bind_int(casestatement, 1, caseID) == SQLITE_OK)
        {
            while(sqlite3_step(casestatement) == SQLITE_ROW)
            {
                tmpList << (const char*)sqlite3_column_text(casestatement, 0);
            }
        }
        else
        {
            emit DisplayError("1.8", "RETURN CASE EVIDENCE", sqlite3_errmsg(wombatdb));
        }
    }
    else
        emit DisplayError("1.8", "RETURN CASE EVIDENCE", sqlite3_errmsg(wombatdb));

    return tmpList;
}

QStringList WombatDatabase::ReturnCaseEvidenceIdJobIdType(int caseid)
{
    QStringList tmplist;
    if(sqlite3_prepare_v2(wombatdb, "SELECT jobid,type,evidenceid FROM job WHERE caseid = ?;", -1, &casestatement, NULL) == SQLITE_OK)
    {
        if(sqlite3_bind_int(casestatement, 1, caseid) == SQLITE_OK)
        {
            while(sqlite3_step(casestatement) == SQLITE_ROW)
            {
                tmplist << QString::number(sqlite3_column_int(casestatement, 0)) << QString::number(sqlite3_column_int(casestatement, 1)) << QString::number(sqlite3_column_int(casestatement, 2));
            }
        }
        else
            emit DisplayError("1.15", "RETURN CASE EVIDENCE ADD JOB ID/TYPE ", sqlite3_errmsg(wombatdb));
    }
    else
        emit DisplayError("1.15", "RETURN CASE EVIDENCE ADD JOB ID/TYPE ", sqlite3_errmsg(wombatdb));

    return tmplist;
}

QStringList WombatDatabase::ReturnEvidenceData(int evidenceid)
{
    QStringList tmplist;
    if(sqlite3_prepare_v2(wombatdb, "SELECT fullpath, name FROM evidence WHERE evidenceid = ?;", -1, &casestatement, NULL) == SQLITE_OK)
    {
        if(sqlite3_bind_int(casestatement, 1, evidenceid) == SQLITE_OK)
        {
            int ret = sqlite3_step(casestatement);
            if(ret == SQLITE_ROW || ret == SQLITE_DONE)
            {
                tmplist << QString((const char*)sqlite3_column_text(casestatement, 0));
                tmplist << QString((const char*)sqlite3_column_text(casestatement, 1));
            }
            else
                emit DisplayError("1.21", "RETURN EVIDENCE DATA ", sqlite3_errmsg(wombatdb));
        }
        else
            emit DisplayError("1.21", "RETURN EVIDENCE DATA ", sqlite3_errmsg(wombatdb));
    }
    else
        emit DisplayError("1.21", "RETURN EVIDENCE DATA ", sqlite3_errmsg(wombatdb));

    return tmplist;
}

QStringList WombatDatabase::ReturnMessageTableEntries(int jobid)
{
    QStringList tmpstringlist;
    QString tmptype;
    if(sqlite3_prepare_v2(wombatdb, "SELECT msgtype, msg FROM msglog WHERE jobid = ?;", -1, &casestatement, NULL) == SQLITE_OK)
    {
        if(sqlite3_bind_int(casestatement, 1, jobid) == SQLITE_OK)
        {
            while(sqlite3_step(casestatement) == SQLITE_ROW)
            {
                if(sqlite3_column_int(casestatement, 0) == 0)
                    tmptype = "[ERROR]";
                else if(sqlite3_column_int(casestatement, 0) == 1)
                    tmptype = "[WARN]";
                else
                    tmptype = "[INFO]";
                tmpstringlist << tmptype << QString((const char*)sqlite3_column_text(casestatement, 1));
            }
        }
        else
            emit DisplayError("1.9", "RETURN MSGTABLE ENTIRES ", sqlite3_errmsg(wombatdb));
    }
    else
        emit DisplayError("1.9", "RETURN MSGTABLE ENTRIES ", sqlite3_errmsg(wombatdb));

    return tmpstringlist;
}

void WombatDatabase::InsertMsg(int caseid, int evidenceid, int jobid, int msgtype, const char* msg)
{
    if(sqlite3_prepare_v2(wombatdb, "INSERT INTO msglog (caseid, evidenceid, jobid, msgtype, msg, datetime) VALUES(?, ?, ?, ?, ?, ?);", -1, &casestatement, NULL) == SQLITE_OK)
    {
        if(sqlite3_bind_int(casestatement, 1, caseid) == SQLITE_OK && sqlite3_bind_int(casestatement, 2, evidenceid) == SQLITE_OK && sqlite3_bind_int(casestatement, 3, jobid) == SQLITE_OK && sqlite3_bind_int(casestatement, 4, msgtype) == SQLITE_OK && sqlite3_bind_text(casestatement, 5, msg, -1, SQLITE_TRANSIENT) == SQLITE_OK && sqlite3_bind_text(casestatement, 6, GetTime().c_str(), -1, SQLITE_TRANSIENT) == SQLITE_OK)
        {
            int ret = sqlite3_step(casestatement);
            if(ret == SQLITE_ROW || ret == SQLITE_DONE)
            {
                // do nothing, it was successful
            }
            else
                emit DisplayError("1.10", "INSERT MSG ", sqlite3_errmsg(wombatdb));
        }
        else
            emit DisplayError("1.10", "INSERT MSG ", sqlite3_errmsg(wombatdb));
    }
    else
        emit DisplayError("1.10", "INSERT MSG ", sqlite3_errmsg(wombatdb));
}

QStringList WombatDatabase::ReturnJobDetails(int jobid)
{
    QStringList tmplist;
    if(sqlite3_prepare_v2(wombatdb, "SELECT end, filecount, processcount, state FROM job WHERE jobid = ?;", -1, &casestatement, NULL) == SQLITE_OK)
    {
        if(sqlite3_bind_int(casestatement, 1, jobid) == SQLITE_OK)
        {
            int ret = sqlite3_step(casestatement);
            if(ret == SQLITE_ROW || ret == SQLITE_DONE)
            {
                tmplist << QString((const char*)sqlite3_column_text(casestatement, 0)) << QString::number(sqlite3_column_int(casestatement, 1)) << QString::number(sqlite3_column_int(casestatement, 2));
                if(sqlite3_column_int(casestatement, 3) == 1)
                    tmplist << "Processing Finished";
                else
                    tmplist << "Processing Finished with Errors";
            }
            else
                emit DisplayError("1.22", "RETURN JOB DETAILS ", sqlite3_errmsg(wombatdb));
        }
        else
            emit DisplayError("1.22", "RETURN JOB DETAILS ", sqlite3_errmsg(wombatdb));
    }
    else
        emit DisplayError("1.22", "RETURN JOB DETAILS ", sqlite3_errmsg(wombatdb));

    return tmplist;
}

void WombatDatabase::UpdateJobEnd(int jobid, int filecount, int processcount)
{
    if(sqlite3_prepare_v2(wombatdb, "UPDATE job SET end = ?, filecount = ?, processcount = ?, state = 1 WHERE jobid = ?;", -1, &casestatement, NULL) == SQLITE_OK)
    {
        if(sqlite3_bind_text(casestatement, 1, GetTime().c_str(), -1, SQLITE_TRANSIENT) == SQLITE_OK && sqlite3_bind_int(casestatement, 2, filecount) == SQLITE_OK && sqlite3_bind_int(casestatement, 3, processcount) == SQLITE_OK && sqlite3_bind_int(casestatement, 4, jobid) == SQLITE_OK)
        {
            int ret = sqlite3_step(casestatement);
            if(ret == SQLITE_ROW || ret == SQLITE_DONE)
            {
                // do nothing, it was successful
            }
            else
            {
                emit DisplayError("1.16", "UPDATE FINISHED JOB ", sqlite3_errmsg(wombatdb));
            }
        }
        else
            emit DisplayError("1.16", "UPDATE FINISHED JOB ", sqlite3_errmsg(wombatdb));
    }
    else
        emit DisplayError("1.16", "UPDATE FINISHED JOB ", sqlite3_errmsg(wombatdb));
}

int WombatDatabase::ReturnJobCaseID(int jobid)
{
    int caseid = 0;
    if(sqlite3_prepare_v2(wombatdb, "SELECT caseid FROM job WHERE jobid = ?;", -1, &casestatement, NULL) == SQLITE_OK)
    {
        if(sqlite3_bind_int(casestatement, 1, jobid) == SQLITE_OK)
        {
            int ret = sqlite3_step(casestatement);
            if(ret == SQLITE_ROW || ret == SQLITE_DONE)
            {
                caseid = sqlite3_column_int(casestatement, 0);
            }
            else
                emit DisplayError("1.23", "RETURN JOB CASE ID ", sqlite3_errmsg(wombatdb));
        }
        else
            emit DisplayError("1.23", "RETURN JOB CASE ID ", sqlite3_errmsg(wombatdb));
    }
    else
        emit DisplayError("1.23", "RETURN JOB CASE ID ", sqlite3_errmsg(wombatdb));

    return caseid;
}

int WombatDatabase::ReturnJobEvidenceID(int jobid)
{
    int evidenceid = 0;
    if(sqlite3_prepare_v2(wombatdb, "SELECT evidenceid FROM job WHERE jobid = ?;", -1, &casestatement, NULL) == SQLITE_OK)
    {
        if(sqlite3_bind_int(casestatement, 1, jobid) == SQLITE_OK)
        {
            int ret = sqlite3_step(casestatement);
            if(ret == SQLITE_ROW || ret == SQLITE_DONE)
            {
                evidenceid = sqlite3_column_int(casestatement, 0);
            }
            else
                emit DisplayError("1.24", "RETURN JOB EVIDENCE ID ", sqlite3_errmsg(wombatdb));
        }
        else
            emit DisplayError("1.24", "RETURN JOB EVIDENCE ID ", sqlite3_errmsg(wombatdb));
    }
    else
        emit DisplayError("1.24", "RETURN JOB EVIDENCE ID ", sqlite3_errmsg(wombatdb));

    return evidenceid;
}

void WombatDatabase::RemoveEvidence(QString evidencename)
{
    if(sqlite3_prepare_v2(wombatdb, "UPDATE evidence SET deleted = 1 WHERE fullpath = ?;", -1, &casestatement, NULL) == SQLITE_OK)
    {
        if(sqlite3_bind_text(casestatement, 1, evidencename.toStdString().c_str(), -1, SQLITE_TRANSIENT) == SQLITE_OK)
        {
            int ret = sqlite3_step(casestatement);
            if(ret == SQLITE_ROW || ret == SQLITE_DONE)
            {
                // do nothing, successful
            }
            else
                emit DisplayError("1.25", "REMOVE EVIDENCE ", sqlite3_errmsg(wombatdb));
        }
        else
            emit DisplayError("1.25", "REMOVE EVIDENCE ", sqlite3_errmsg(wombatdb));
    }
    else
        emit DisplayError("1.25", "REMOVE EVIDENCE ", sqlite3_errmsg(wombatdb));
}

int WombatDatabase::ReturnEvidenceID(QString evidencename)
{
    int evidenceid = 0;
    if(sqlite3_prepare_v2(wombatdb, "SELECT evidenceid FROM evidence WHERE fullpath = ? and deleted = 0;", -1, &casestatement, NULL) == SQLITE_OK)
    {
        if(sqlite3_bind_text(casestatement, 1, evidencename.toStdString().c_str(), -1, SQLITE_TRANSIENT) == SQLITE_OK)
        {
            int ret = sqlite3_step(casestatement);
            if(ret == SQLITE_ROW || ret == SQLITE_DONE)
            {
                evidenceid = sqlite3_column_int(casestatement, 0);
            }
            else
                emit DisplayError("1.26", "RETURN EVIDENCE ID FROM NAME ", sqlite3_errmsg(wombatdb));
        }
        else
            emit DisplayError("1.26", "RETURN EVIDENCE ID FROM NAME ", sqlite3_errmsg(wombatdb));
    }
    else
        emit DisplayError("1.26", "RETURN EVIDENCE ID FROM NAME ", sqlite3_errmsg(wombatdb));

    return evidenceid;
}

int WombatDatabase::ReturnEvidenceDeletedState(int evidenceid)
{
    int isdeleted = 0;
    if(sqlite3_prepare_v2(wombatdb, "SELECT deleted FROM evidence WHERE evidenceid = ?;", -1, &casestatement, NULL) == SQLITE_OK)
    {
        if(sqlite3_bind_int(casestatement, 1, evidenceid) == SQLITE_OK)
        {
            int ret = sqlite3_step(casestatement);
            if(ret == SQLITE_ROW || ret == SQLITE_DONE)
            {
                isdeleted = sqlite3_column_int(casestatement, 0);
            }
            else
                emit DisplayError("1.28", "RETURN EVIDENCE DELETED STATE FROM ID ", sqlite3_errmsg(wombatdb));
        }
        else
            emit DisplayError("1.28", "RETURN EVIDENCE DELETED STATE FROM ID ", sqlite3_errmsg(wombatdb));
    }
    else
        emit DisplayError("1.28", "RETURN EVIDENCE DELETED STATE FROM ID ", sqlite3_errmsg(wombatdb));

    return isdeleted;
}

QString WombatDatabase::ReturnEvidencePath(int evidenceid)
{
    QString epath = "";
    if(sqlite3_prepare_v2(wombatdb, "SELECT fullpath FROM evidence WHERE evidenceid = ?;", -1, &casestatement, NULL) == SQLITE_OK)
    {
        if(sqlite3_bind_int(casestatement, 1, evidenceid) == SQLITE_OK)
        {
            int ret = sqlite3_step(casestatement);
            if(ret == SQLITE_ROW || ret == SQLITE_DONE)
            {
                epath = QString((const char*)sqlite3_column_text(casestatement, 0));
            }
            else
                emit DisplayError("1.27", "RETURN EVIDENCE PATH FROM ID ", sqlite3_errmsg(wombatdb));
        }
        else
            emit DisplayError("1.27", "RETURN EVIDENCE PATH FROM ID ", sqlite3_errmsg(wombatdb));
    }
    else
        emit DisplayError("1.27", "RETURN EVIDENCE PATH FROM ID ", sqlite3_errmsg(wombatdb));

    return epath;
}*/
---------------------
wombatframework.cpp
---------------------
// OLD STUFF THAT IS USEFULL INFO FOR HOW TO GET THINGS, BUT NOT USED IN THIS CODE RIGHT NOW
    /*
    int retval;
    //tmpelement.appendInside("<br/><table><tr><th>byte offset</th><th>value</th><th>description</th></tr><tr class='odd'><td>0-2</td><td class='bvalue'>" + wombatvarptr->bootsectorlist[0] + "</td><td class='desc'>Jump instruction to the boot code</td></tr><tr class='even'><td>3-10</td><td class='bvalue'>" + wombatvarptr->bootsectorlist[1] + "</td><td class='desc'>OEM name string field. This field is ignored by Microsoft operating systems</td></tr><tr class='odd'><td>11-12</td><td class='bvalue'>" + wombatvarptr->bootsectorlist[2] + " bytes</td><td class='desc'>Bytes per sector</td></tr><tr class='even'><td>13-13</td><td class='bvalue'>" + wombatvarptr->bootsectorlist[3] + " sectors</td><td class='desc'>Seectors per cluster</td></tr><tr class='odd'><td colspan='3' class='bot'></td></tr></table>");*/
    /*
    QString tmpstr = "";
    char* bootbuffer = NULL;
    wombatptr->rawbyteintvector.clear();
    bootbuffer = new char[wombatptr->evidenceobject.imageinfo->sector_size];
    retval = tsk_img_read(wombatptr->evidenceobject.imageinfo, 0, bootbuffer, wombatptr->evidenceobject.imageinfo->sector_size);
    if(retval > 0)
    {
        wombatptr->rawbyteintvector.resize(wombatptr->evidenceobject.imageinfo->sector_size);
        for(int i=0; i < retval; i++)
        {
            wombatptr->rawbyteintvector[i] = bootbuffer[i];
        }
        delete[] bootbuffer;
        // delete bootbuffer;
        //qDebug() << "Byte to Hex: " << Translate::ByteToHex(wombatptr->rawbyteintvector[510]);
        //qDebug() << "Byte to Int: " << wombatptr->rawbyteintvector[510];
        vector<uchar> subchar;
        subchar.push_back(wombatptr->rawbyteintvector[510]);
        subchar.push_back(wombatptr->rawbyteintvector[511]);
        Translate::ByteToHex(tmpstr, subchar);
        if(QString::compare("55aa", tmpstr) == 0) // its a boot sector
        {
                // now to determine if its got a partition table
        }
        //Translate::ByteToBinary(tmpstr, subchar);
        //qDebug() << "Byte to Bin: " << tmpstr;
    }
    */
// BELOW FUNCTION CURRENTLY NOT USED
void WombatFramework::BuildEvidenceModel()
{
    // COME BACK TO QTCONCURRENT AS I GET FARTHER ALONG AND RESEARCH MORE
    /*
    QVector<ItemObject> itemvector;
    for(int i = 0; i < wombatptr->evidenceobjectvector.count(); i++)
    {
        itemvector.append(wombatptr->evidenceobjectvector[i]);
    }
    QFutureWatcher<void> watcher;
    watcher.setFuture(QtConcurrent::map(itemvector, &WombatFramework::OpenEvidenceImages));
    //watcher.setFuture(QtConcurrent::map(wombatptr->evidenceobjectvector, WombatFramework::OpenEvidenceImages));
    watcher.waitForFinished();
    */
    OpenEvidenceImages(); // PROBABLY PUT THIS IN A MULTI-THREAD ENVIRONMENT.
    for(int i=0; i < wombatptr->evidenceobjectvector.count(); i++) // for each evidence image info file.
    {
        if(wombatptr->evidenceobjectvector[i].imageinfo == NULL)
            fprintf(stderr, "Image didn't open. add to log file as error.\n");
        else
            fprintf(stderr, "Image %s opened. add to log file as info.\n", wombatptr->evidenceobjectvector[i].fullpathvector[0].c_str());
    }
    // NEED TO LAUNCH THIS IN A NEW THREAD TO KEEP GUI RESPONSIVE
    // NEED TO OPEN THE IMAGE - img_open.c [tsk_img_open()]
    // NEED TO GET THE METADATA FOR THE IMAGE/VOLUMES/PARTITIONS/FILES SO I CAN POPULATE THE DIRECTORY TREE INFORMATION


    // NEED TO ADD THE EVIDENCE ITEM TO THE DATABASE
    // POPULATE THE WOMBATVARPTR FOR THE EVIDENCEOBJECT VECTOR
    // NEED TO CREATE THE EVIDENCE TSK DATABASE (EXTRACT EVIDENCE ACCORDING TO MODULES)
    // NEED TO BUILD DIRMODEL AS I GO AND POPULATE DIRTREEVIEW AS I GO WITH EACH FILE
    // FOR NOW I WON'T BUILD MODULES, I'LL JUST DESIGN A MULTI-THREADED APPROACH FOR IT AND ABSTRACT TO PLUGGABLE MODULES LATER

    /*
    QFutureWatcher<void> watcher;
    std::vector<TskSchedulerQueue::task_struct* > tmpvector;
    watcher.setFuture(QtConcurrent::map(&tmpvector, &SleuthKitPlugin::TaskMap));
    //watcher.setFuture(QtConcurrent::map(&((std::vector<TskSchedulerQueue::task_struct*>)scheduler.mapvector), &SleuthKitPlugin::TaskMap));
    watcher.waitForFinished();
    */
    // QT CONCURRENT TEST
}
------------------------------
wombatfunctions.h
------------------------------

//template <typename Iterator>
//BytesToBinary(Iterator start, Iterator end);
/*
template<typename T>
void BytesToBinary(T start, T end)
{
    for(T it = start; it != end; ++it)
    {
        //qDebug() << "Byte to Hex: " << Translate::ByteToHex(it);
        cout << it;
    }
};*/
//QString ByteArrayToHex(QByteArray ba);
//QString ByteArrayToHexDisplay(QByteArray ba);
//QString ByteArrayToShortDisplay(QByteArray ba);
//QString ByteArrayToString(QByteArray ba, int base);
//QString SingleByteToString(QByteArray ba, int base);
//int CheckBitSet(unsigned char c, int n);
------------------------
wombatfunctions.cpp
------------------------

/*
BytesToBinary(Iterator start, Iterator end)
{
    for(Iterator it = start; it != end; ++it)
    {
        qDebug() << "Byte to Hex: " << Translate::ByteToHex(it);
    }
}
*/
/*
QString ByteArrayToShortDisplay(QByteArray ba)
{
    short intvalue = 0;
    memcpy(&intvalue, &ba.begin()[0], sizeof(short));
    QString tmpstring = "";
    return tmpstring.setNum(intvalue);
}

QString SingleByteToString(QByteArray ba, int base)
{
    short intvalue = 0;
    memcpy(&intvalue, &ba.begin()[0], sizeof(short));
    QString tmpstring = "";
    tmpstring.setNum(intvalue, base);
    qDebug() << "Temp Value: " << tmpstring;
    if(base == 2 && tmpstring.size() < 8)
    {
    	int zerocount = 8 - tmpstring.size();
	tmpstring.prepend(QString::fromStdString(std::string(zerocount, '0')));
	return tmpstring;
    }
    else
    	return tmpstring;
}
// NEED TO FIX THE BYTE ARRAY TO STRING TO ACCOUNT FOR THE LENGTH OF THE BYTE ARRAY...
QString ByteArrayToString(QByteArray ba, int base)
{
    int intvalue = 0;
    memcpy(&intvalue, &ba.begin()[0], sizeof(int));
    QString tmpstring = "";
    tmpstring.setNum(intvalue, base);
    if(base == 2 && tmpstring.size() < 8)
    {
    	int zerocount = 8 - tmpstring.size();
	tmpstring.prepend(QString::fromStdString(std::string(zerocount, '0')));
	return tmpstring;
    }
    else
    	return tmpstring;
}

QString ByteArrayToHex(QByteArray ba)
{
    QString tmpstring = QString::fromUtf8(ba.toHex());
    QString outstring = "";
    for(int i=0; i < tmpstring.size() / 2; ++i)
    {
        outstring += tmpstring.at(2*i);
        outstring += tmpstring.at(2*i+1);
    }

    return outstring;
}

QString ByteArrayToHexDisplay(QByteArray ba)
{
    QString tmpstring = QString::fromUtf8(ba.toHex());
    QString outstring = "";
    for(int i=0; i < tmpstring.size()/2; ++i)
    {
        outstring += tmpstring.at(2*i);
        outstring += tmpstring.at(2*i+1);
        if(i < tmpstring.size()/2 - 1)
            outstring += " ";
    }

    return outstring;
}


// COMPARE THE STRING VALUE TO DETERMINE IF ITS SET TO 1 OR NOT.
int CheckBitSet(unsigned char c, int n)
{
    static unsigned char mask[] = {1, 2, 4, 8, 16, 32, 64, 128};
    //static unsigned char mask[] = {128, 64, 32, 16, 8, 4, 2, 1};
    return ((c & mask[n]) != 0);
}*/
--------------------------
sleuthkit.cpp
--------------------------
#include "sleuthkit.h"

static std::string getFileType(const char *name)
{
    std::string filename = name;
    size_t pos = filename.rfind('.');
    if (pos != std::string::npos)
    {
        std::string suffix = filename.substr(pos);
        std::string result;
        for (size_t i=0; i < suffix.size(); i++)
        {
            result += (char)tolower(suffix[i]);
        }
        return result;
    }
    else
        return std::string("");
}
QString DisplayTimeUTC(int unixtime)
{
    QDateTime tmptime;
    QString tmpstring = "";
    tmptime.setTime_t(unixtime);
    tmptime.setTimeSpec(Qt::UTC);
    if(tmptime.date().toString(Qt::ISODate).compare("1969-12-31") != 0)
        tmpstring = tmptime.toString(Qt::ISODate);
    
    return tmpstring;
}

SleuthKitPlugin::SleuthKitPlugin(WombatDatabase* wombatcasedata)
{
    wombatdata = wombatcasedata; 
}
void SleuthKitPlugin::Initialize(WombatVariable* wombatVariable)
{
    wombatvariable = wombatVariable;
    SetupSystemProperties();
    SetupLog();
    SetupScheduler();
    SetupFileManager();
    SetupImageDatabase();
    SetupBlackboard();
    //fprintf(stderr, "SleuthKit Exists\n");
    qRegisterMetaType<WombatVariable*>("WombatVariable*");
    connect(this, SIGNAL(SetLogVariable(WombatVariable*)), log, SLOT(LogVariable(WombatVariable*)), Qt::DirectConnection);
}

void SleuthKitPlugin::SetupImageDatabase()
{
    // initialize dummy database to create copy new imagedb's from.
    try
    {
        initialdb = new TskImgDBSqlite(wombatvariable->datapath.toStdString().c_str(), "initial.db");
        if(initialdb->initialize() != 0)
            fprintf(stderr, "Error initializing StarterDB\n");
        else
        {
            //fprintf(stderr, "Starter DB was Initialized Successfully!\n");
        }
        TskServices::Instance().setImgDB(*initialdb);
        //fprintf(stderr, "Loading Starter ImageDB was Successful!\n");
    }
    catch(TskException &ex)
    {
        fprintf(stderr, "Loading Starter ImageDB: %s\n", ex.message().c_str());
    }
}

void SleuthKitPlugin::OpenEvidence(WombatVariable* wombatVariable)
{
    wombatvariable = wombatVariable;
    QString oldstring = wombatvariable->datapath + "initial.db";
    QString newstring = wombatvariable->evidencedirpath + wombatvariable->evidencedbname;
    if(QFile::copy(oldstring.toStdString().c_str(), newstring.toStdString().c_str()))
    {
        //fprintf(stderr, "File Copy Was Successful\n");
        // copy was successful
        try
        {
            tmpdb = new TskImgDBSqlite(wombatvariable->evidencedirpath.toStdString().c_str(), wombatvariable->evidencedbname.toStdString().c_str());
        }
        catch(TskException &ex)
        {
            fprintf(stderr, "Tsk New Exception: %s\n", ex.message().c_str());
        }
        try
        {
            if(tmpdb->initialize() != 0)
                fprintf(stderr, "Error intializing Evidence DB\n");
            else
            {
                //fprintf(stderr, "Evidence DB was initialized successfully\n");
            }
        }
        catch(TskException &ex)
        {
            fprintf(stderr, "Tsk Open Exception: %s\n", ex.message().c_str());
        }
        try
        {
            TskServices::Instance().setImgDB(*tmpdb);
        }
        catch(TskException &ex)
        {
            fprintf(stderr, "Services Set ImageDB: %s\n", ex.message().c_str());
        }
    }
    else
    {
        fprintf(stderr, "File Copy was NOT successful\n");
        // copy was not successful
        // exit out with error that image already added...
    }
    //fprintf(stderr, "Evidence ImgDB Path: %s\n", wombatvariable->evidencepath.toStdString().c_str());
    
    int filecount = 0;
    int processcount = 0;
    TskImageFileTsk imagefiletsk;
    try
    {
        imagefiletsk.open(wombatvariable->evidencepath.toStdString());
        TskServices::Instance().setImageFile(imagefiletsk);
        //fprintf(stderr, "Opening Image File was successful!\n");
    }
    catch(TskException &ex)
    {
        fprintf(stderr, "Opening Evidence: %s\n", ex.message().c_str());
    }
    try
    {
        imagefiletsk.extractFiles(); // modify this function to set my respective objectid's in my db's.
        //fprintf(stderr, "Extracting Evidence was successful\n");
    }
    catch(TskException &ex)
    {
        fprintf(stderr, "Extracting Evidence: %s\n", ex.message().c_str());
    }
    // Get Number of Files found here 
    filecount = TskServices::Instance().getImgDB().getNumFiles();
    emit UpdateStatus(filecount, processcount);
    LOGINFO("Processing Evidence Started");
    wombatdata->InsertMsg(wombatvariable->caseid, wombatvariable->evidenceid, wombatvariable->jobid, 2, "Processing Evidence Started");
    TskSchedulerQueue::task_struct *task;
    TskPipelineManager pipelinemgr;
    TskPipeline* filepipeline;
    TskSchedulerQueue::task_struct* currenttask;
    try
    {
        filepipeline = pipelinemgr.createPipeline(TskPipelineManager::FILE_ANALYSIS_PIPELINE);
    }
    catch(const TskException &ex)
    {
        fprintf(stderr, "Error creating file analysis pipeline: %s\n", ex.message().c_str());
    }
    // HOW ABOUT LOOP OF RUNNABLES...
    //
    /*
    for(int i=0; i < scheduler.mapvector.size(); i++)
    {
        currenttask = scheduler.mapvector[i];
        try
        {
            if(currenttask->task == Scheduler::FileAnalysis && filepipeline && !filepipeline->isEmpty())
            {
                TaskRunner* trunner = new TaskRunner(currenttask, filepipeline);
                QThreadPool::globalInstance()->start(trunner);
                //filepipeline->run(task->id);
            }
            else
            {
                fprintf(stderr, "Skipping task: %d\n", task->task);
            }
            //delete task;
        }
        catch(TskException &ex)
        {
            fprintf(stderr, "TskException: %s\n", ex.message().c_str());
        }

        //processcount++;
        //emit UpdateStatus(filecount, processcount);
        //emit UpdateMessageTable();

        //TaskRunner* trunner = new TaskRunner(scheduler.mapvector[i], filepipeline);
        //QThreadPool::globalInstance()->start(trunner);
    }
    delete currenttask;
    */
    /*
    QFutureWatcher<void> watcher;
    std::vector<TskSchedulerQueue::task_struct* > tmpvector;
    watcher.setFuture(QtConcurrent::map(&tmpvector, &SleuthKitPlugin::TaskMap));
    //watcher.setFuture(QtConcurrent::map(&((std::vector<TskSchedulerQueue::task_struct*>)scheduler.mapvector), &SleuthKitPlugin::TaskMap));
    watcher.waitForFinished();
    */
    // QT CONCURRENT TEST
    while((task = scheduler.nextTask()) != NULL)
    {
        try
        {
            if(task->task == Scheduler::FileAnalysis && filepipeline && !filepipeline->isEmpty())
            {
                filepipeline->run(task->id);
            }
            else
            {
                fprintf(stderr, "Skipping task: %d\n", task->task);
            }
            delete task;
        }
        catch(TskException &ex)
        {
            fprintf(stderr, "TskException: %s\n", ex.message().c_str());
        }
        processcount++;
        emit UpdateStatus(filecount, processcount);
        emit UpdateMessageTable();
    }
    if(filepipeline && !filepipeline->isEmpty())
    {
        filepipeline->logModuleExecutionTimes();
    }
    LOGINFO("Processing Evidence Finished");
    wombatdata->InsertMsg(wombatvariable->caseid, wombatvariable->evidenceid, wombatvariable->jobid, 2, "Processing Evidence Finished");
    //fprintf(stderr, "File Count: %d - Process Count: %d\n", filecount, processcount);
    wombatdata->UpdateJobEnd(wombatvariable->jobid, filecount, processcount);
    GetImageTree(wombatvariable, 1);
    LOGINFO("Adding Evidence Finished");
    wombatdata->InsertMsg(wombatvariable->caseid, wombatvariable->evidenceid, wombatvariable->jobid, 2, "Adding Evidence Finished");
}

void SleuthKitPlugin::TaskMap(TskSchedulerQueue::task_struct* &task)
{
    TskPipelineManager pipelinemgr;
    TskPipeline* filepipeline;
    try
    {
        filepipeline = pipelinemgr.createPipeline(TskPipelineManager::FILE_ANALYSIS_PIPELINE);
    }
    catch(const TskException &ex)
    {
        fprintf(stderr, "Error creating file analysis pipeline: %s\n", ex.message().c_str());
    }
    try
    {
        if(task->task == Scheduler::FileAnalysis && filepipeline && !filepipeline->isEmpty())
        {
            filepipeline->run(task->id);
        }
        else
        {
            fprintf(stderr, "Skipping task: %d\n", task->task);
        }
    }
    catch(TskException &ex)
    {
        fprintf(stderr, "TskException: %s\n", ex.message().c_str());
    }
    if(filepipeline && !filepipeline->isEmpty())
    {
        filepipeline->logModuleExecutionTimes();
    }
}

void SleuthKitPlugin::SetEvidenceDB(WombatVariable* wombatVariable)
{
    wombatvariable = wombatVariable;
    try
    {
        tmpdb = new TskImgDBSqlite(wombatvariable->evidencedirpath.toStdString().c_str(), wombatvariable->evidencedbname.toStdString().c_str());
    }
    catch(TskException &ex)
    {
        fprintf(stderr, "Tsk New Exception: %s\n", ex.message().c_str());
    }
    try
    {
        if(tmpdb->open() != 0)
            fprintf(stderr, "Error intializing Evidence DB\n");
        else
        {
            //fprintf(stderr, "Evidence DB was initialized successfully\n");
        }
    }
    catch(TskException &ex)
    {
        fprintf(stderr, "Tsk Open Exception: %s\n", ex.message().c_str());
    }
    try
    {
        TskServices::Instance().setImgDB(*tmpdb);
    }
    catch(TskException &ex)
    {
        fprintf(stderr, "Services Set ImageDB: %s\n", ex.message().c_str());
    }
}

void SleuthKitPlugin::ShowFile(WombatVariable* wombatVariable)
{
    // HERE IS WHERE I NEED TO GET WHAT I NEED FOR EACH VIEWER.
    // I NEED TO DETERMINE WHICH VIEWER IS VISIBLE AND THEN LOAD WHEN CLICKED.
    /*
    QString curtmpfilepath = "";
    wombatvariable = wombatVariable;
    SetEvidenceDB(wombatvariable);
    //fprintf(stderr, "file id: %i\n", wombatvariable->fileid);
    if(wombatvariable->fileid >= 0)
        curtmpfilepath = GetFileContents(wombatvariable->fileid);
    else if(wombatvariable->fileid == -1) // image file
    {
        // this won't work for e01 files, so i'll have to figure out how to read the damn thing in properly.
        curtmpfilepath = wombatvariable->evidencepath;
        //fprintf(stderr, "dd image path: %s\n", wombatvariable->evidencepath.toStdString().c_str());
        // QString imagename = wombatvariable->evidencepath.split("/").last();
    }
    else if(wombatvariable->fileid == -2) // volume file
    {
        curtmpfilepath = GetVolumeFilePath(wombatvariable-> wombatvariable->volid);
        //fprintf(stderr, "tmp file path: %s\n", wombatvariable->tmpfilepath.toStdString().c_str());
        //fprintf(stderr, "vol file path %s\n", curtmpfilepath.toStdString().c_str());
    }
    else if(wombatvariable->fileid == -3) // file system file
    {
        // fs_info sql call provides root_inum and last inum.
        // 
    }
    else
        curtmpfilepath = ""; // set to "" to load nothing.
    emit LoadFileContents(curtmpfilepath);
    */
}

void SleuthKitPlugin::ExportFiles(WombatVariable* wombatVariable)
{
    wombatvariable = wombatVariable;
    int processcount = 0;
    for(int i = 0; i < wombatvariable->exportdatalist.size(); i++)
    {
        processcount++;
        wombatvariable->evidencepath = QString::fromStdString(wombatvariable->exportdatalist[i].evidencepath);
        wombatvariable->evidencedbname = QString::fromStdString(wombatvariable->exportdatalist[i].evidencedbname);
        SetEvidenceDB(wombatvariable);
        ExportFile(wombatvariable->exportdatalist[i].fullpath, wombatvariable->exportdatalist[i].id);
        std::string tmpstring = wombatvariable->exportdatalist[i].fullpath + " Exported";
        wombatdata->InsertMsg(wombatvariable->caseid, wombatvariable->evidenceid, wombatvariable->jobid, 2, tmpstring.c_str());
        emit UpdateStatus(wombatvariable->exportdatalist[i].exportcount, processcount);
        emit UpdateMessageTable();
    }
    FinishExport(processcount);
}

void SleuthKitPlugin::FinishExport(int processcount)
{
    LOGINFO("File Export Finished");
    wombatdata->InsertMsg(wombatvariable->caseid, wombatvariable->evidenceid, wombatvariable->jobid, 2, "File Export Finished");
    wombatdata->UpdateJobEnd(wombatvariable->jobid, wombatvariable->exportdatalist[0].exportcount, processcount);
    emit UpdateMessageTable();
}

void SleuthKitPlugin::RefreshTreeViews(WombatVariable* wombatVariable)
{
    wombatvariable = wombatVariable;
    QStringList evidencelist = wombatdata->ReturnCaseActiveEvidenceID(wombatvariable->caseid);
    for(int i=0; (i < evidencelist.count() / 3); i++)
    {
        wombatvariable->evidenceid = evidencelist[3*i].toInt();
        wombatvariable->evidencepath = evidencelist[(3*i+1)];
        wombatvariable->evidencedbname = evidencelist[(3*i+2)];
        SetEvidenceDB(wombatvariable);
        GetImageTree(wombatvariable, 0);
    }
}

void SleuthKitPlugin::PopulateCase(WombatVariable* wombatVariable)
{
    wombatvariable = wombatVariable;
    QStringList evidencepathlist;
    QStringList evidencejoblist = wombatdata->ReturnCaseEvidenceIdJobIdType(wombatvariable->caseid);
    int isevidencedeleted = 0;
    for(int i=0; i < (evidencejoblist.count() / 3); i++)
    {
        wombatvariable->jobid = evidencejoblist[(3*i)].toInt();
        wombatvariable->jobtype = evidencejoblist[(3*i+1)].toInt();
        wombatvariable->evidenceid = evidencejoblist[(3*i)+2].toInt();
        wombatvariable->evidencepath = wombatdata->ReturnEvidencePath(wombatvariable->evidenceid);
        isevidencedeleted = wombatdata->ReturnEvidenceDeletedState(wombatvariable->evidenceid);
        wombatvariable->evidencedbname = wombatvariable->evidencepath.split("/").last() + ".db";
        emit SetLogVariable(wombatvariable);
        if(isevidencedeleted == 0 && wombatvariable->jobtype == 1)
        {
            SetEvidenceDB(wombatvariable);
            GetImageTree(wombatvariable, 0);
        }
        emit PopulateProgressWindow(wombatvariable);
    }
}

void SleuthKitPlugin::SetupSystemProperties()
{
    QString tmpPath = wombatvariable->settingspath;
    tmpPath += "/tsk-config.xml";
    QFile tmpFile(tmpPath);
    if(!tmpFile.exists()) // if tsk-config.xml does not exist, create and write it here
    {
        if(tmpFile.open(QFile::WriteOnly | QFile::Text))
        {   
            QXmlStreamWriter xml(&tmpFile);
            xml.setAutoFormatting(true);
            xml.writeStartDocument();
            xml.writeStartElement("TSK_FRAMEWORK_CONFIG");
            xml.writeStartElement("CONFIG_DIR");
            xml.writeCharacters(wombatvariable->settingspath);
            xml.writeEndElement();
            xml.writeStartElement("MODULE_DIR");
            xml.writeCharacters("/usr/local/lib");
            xml.writeEndElement();
            xml.writeStartElement("MODULE_CONFIG_DIR");
            xml.writeCharacters("/usr/local/share/tsk");
            xml.writeEndElement();
            xml.writeStartElement("OUT_DIR");
            xml.writeCharacters(wombatvariable->tmpfilepath);
            xml.writeEndElement();
            xml.writeStartElement("SYSTEM_OUT_DIR");
            xml.writeCharacters("#OUT_DIR#/SystemOutput");
            xml.writeEndElement();
            xml.writeStartElement("PIPELINE_CONFIG_FILE");
            xml.writeCharacters("#CONFIG_DIR#/tsk-pipe.xml");
            xml.writeEndElement();
            xml.writeEndElement();
            xml.writeEndDocument();
        }
        else
        {
            fprintf(stderr, "Could not open file to write\n");
        }
        tmpFile.close();
    }
    try
    {
        systemproperties = new TskSystemPropertiesImpl();
        systemproperties->initialize(tmpPath.toStdString());
        TskServices::Instance().setSystemProperties(*systemproperties);
        //fprintf(stderr, "Configuration File Loading was successful!\n");
    }
    catch(TskException &ex)
    {
        fprintf(stderr, "Loading Config File config file: %s\n", ex.message().c_str());
    }
    tmpPath = wombatvariable->settingspath;
    tmpPath += "/tsk-pipe.xml";
    QFile pipeFile(tmpPath);
    //fprintf(stderr, "PipPath: %s\n", tmpPath.toStdString().c_str());
    if(!pipeFile.exists()) // if tsk-pipe.xml does not exist, create and write it here
    {
        if(pipeFile.open(QFile::WriteOnly | QFile::Text))
        {
            QXmlStreamWriter pxml(&pipeFile);
            pxml.setAutoFormatting(true);
            pxml.writeStartDocument();
            pxml.writeStartElement("PIPELINE_CONFIG");
            pxml.writeStartElement("PIPELINE");
            pxml.writeAttribute("type", "FileAnalysis");
            pxml.writeStartElement("MODULE");
            pxml.writeAttribute("order", "1");
            pxml.writeAttribute("type", "plugin");
            pxml.writeAttribute("location", "tskHashCalcModule");
            pxml.writeEndElement();
            pxml.writeStartElement("MODULE");
            pxml.writeAttribute("order", "2");
            pxml.writeAttribute("type", "plugin");
            pxml.writeAttribute("location", "tskFileTypeSigModule");
            pxml.writeEndElement();
            pxml.writeEndElement();
            pxml.writeEndElement();
            pxml.writeEndDocument();
        }
        else
            fprintf(stderr, "Could not open file for writing\n");
        pipeFile.close();
    }
    tmpPath = wombatvariable->settingspath;
    tmpPath += "/tsk-magicview.xml";
    QFile magicFile(tmpPath);
    if(!magicFile.exists()) // if tsk-magic.xml does not exist, create and write it here.
    {
        if(magicFile.open(QFile::WriteOnly | QFile::Text))
        {
            // 1 = web, 2 = pic, 3 = vid.
            QXmlStreamWriter mxml(&magicFile);
            mxml.setAutoFormatting(true);
            mxml.writeStartDocument();
            mxml.writeStartElement("signatures"); // start signatures
            mxml.writeStartElement("signature"); // start signature
            mxml.writeAttribute("viewer", "1");
            mxml.writeCharacters("HTML document");
            mxml.writeEndElement(); // end signature
            mxml.writeStartElement("signature"); // start signature
            mxml.writeAttribute("viewer", "2");
            mxml.writeCharacters("JPEG image data");
            mxml.writeEndElement(); // signature
            mxml.writeStartElement("signature"); // start signature
            mxml.writeAttribute("viewer", "3");
            mxml.writeCharacters("MPEG sequence");
            mxml.writeEndElement(); // signature
            mxml.writeEndElement(); // signatures
            mxml.writeEndDocument();
        }
        else
            fprintf(stderr, "Could not open magic file for writing\n");
        magicFile.close();
    }

    // make the output directories
    if(!(new QDir())->mkpath(QString::fromStdString(GetSystemProperty(TskSystemProperties::OUT_DIR))))
        fprintf(stderr, "out_dir failed\n");
    if(!(new QDir())->mkpath(QString::fromStdString(GetSystemProperty(TskSystemProperties::SYSTEM_OUT_DIR))))
        fprintf(stderr, "system_out_dir failed\n");
    if(!(new QDir())->mkpath(QString::fromStdString(GetSystemProperty(TskSystemProperties::MODULE_OUT_DIR))))
        fprintf(stderr, "module_out_dir failed\n");
}
void SleuthKitPlugin::SetupLog()
{
    QString tmpPath = wombatvariable->datapath + "tsk-log.txt";
    try
    {
        log = new TskLog(wombatvariable->datapath.toStdString());
        log->open(tmpPath.toStdString().c_str());
        TskServices::Instance().setLog(*log);
        //fprintf(stderr, "Loading Log File was successful!\n");
    }
    catch(TskException &ex)
    {
        fprintf(stderr, "Loading Log File: %s\n", ex.message().c_str());
    }
}

void SleuthKitPlugin::SetupBlackboard()
{
    try
    {
        TskServices::Instance().setBlackboard((TskBlackboard &)TskDBBlackboard::instance());
        //fprintf(stderr, "Loading Blackboard was successful!\n");
    }
    catch(TskException &ex)
    {
        fprintf(stderr, "Loading Blackboard: %s\n", ex.message().c_str());
    }
}

void SleuthKitPlugin::SetupScheduler()
{
    try
    {
        TskServices::Instance().setScheduler(scheduler);
        //fprintf(stderr, "Loading Scheduler was successful!\n");
    }
    catch(TskException &ex)
    {
        fprintf(stderr, "Loading Scheduler: %s\n", ex.message().c_str());
    }
}

void SleuthKitPlugin::SetupFileManager()
{
    try
    {
        TskServices::Instance().setFileManager(fileManager->instance());
        //fprintf(stderr, "Loading File Manager was successful!\n");
    }
    catch(TskException &ex)
    {
        fprintf(stderr, "Loading FileManager: %s\n", ex.message().c_str());
    }
}

void SleuthKitPlugin::threadFinished()
{
    fprintf(stderr, "The Thread Finished. ");
}

// This takes too long to populate. need to come up with a more efficient way to populate these values that won't take as long
// Need to move the insertobject out of the get image tree function
void SleuthKitPlugin::GetImageTree(WombatVariable* wombatvariable, int isAddEvidence)
{
    QString imagename = wombatvariable->evidencepath.split("/").last();
    std::vector<TskFileRecord> fileRecordVector;
    std::list<TskVolumeInfoRecord> volRecordList;
    std::list<TskFsInfoRecord> fsInfoRecordList;
    QString fullPath = "";
    QString currentVolPath = "";
    QString currentFsPath = "";
    TskFileRecord tmpRecord;
    TskVolumeInfoRecord volRecord;
    TskFsInfoRecord fsInfoRecord;
    QStandardItem *fsNode;
    QStandardItem *volNode;
    QStandardItem *imageNode = new QStandardItem(imagename);
    imageNode->setIcon(QIcon(":/basic/treeimage"));
    int ret;
    uint64_t tmpId;
    volRecordList.clear();
    fileRecordVector.clear();
    fsInfoRecordList.clear();
    // also need to get the partitions and volumes as nodes.
    ret = TskServices::Instance().getImgDB().getVolumeInfo(volRecordList);
    //fprintf(stderr, "volrecordlist count: %d\n", volRecordList.count());
    foreach(volRecord, volRecordList) // populates all vol's and fs's.
    {
        // if volflag = 0, get description
        // if volflag = 1, list as unallocated
        //fprintf(stderr, "Vol Description: %s - VolFlags: %d\n", volRecord.description.c_str(), volRecord.flags);
        if(volRecord.flags >= 0 && volRecord.flags <= 2)
        {
            if(volRecord.flags == 1)
            {
                volNode = new QStandardItem(QString::fromUtf8(volRecord.description.c_str()));
                volNode->setIcon(QIcon(":/basic/treefilemanager"));
                currentVolPath = QString::fromUtf8(volRecord.description.c_str()) + "/";
            }
            else if(volRecord.flags == 0)
            {
                volNode = new QStandardItem("unallocated space");
                volNode->setIcon(QIcon(":/basic/treefilemanager"));
                currentVolPath = "unallocated space/";
            }
            else if(volRecord.flags == 2)
            {
                volNode = new QStandardItem(QString::fromUtf8(volRecord.description.c_str()));
                volNode->setIcon(QIcon(":/basic/treefilemanager"));
                currentVolPath = QString::fromUtf8(volRecord.description.c_str());
                currentVolPath += "/";
            }
            else
            {
                // don't display anything
            }
            // for each volrecord, get fsinfo list
            imageNode->appendRow(volNode);
            ret = TskServices::Instance().getImgDB().getFsInfo(fsInfoRecordList);
            foreach(fsInfoRecord, fsInfoRecordList)
            {
                if(fsInfoRecord.vol_id == volRecord.vol_id)
                {
                    QString fsType = "";
                    // NEED TO DO SWITCH/CASE HERE TO GET FSTYPE
                    if(fsInfoRecord.fs_type == 1)
                        fsType = "NTFS";
                    else if(fsInfoRecord.fs_type == 3)
                        fsType = "FAT12";
                    else if(fsInfoRecord.fs_type == 4)
                        fsType = "FAT16";
                    else if(fsInfoRecord.fs_type == 5)
                        fsType = "FAT32";
                    else if(fsInfoRecord.fs_type == 7)
                        fsType = "UFS1";
                    else if(fsInfoRecord.fs_type == 8)
                        fsType = "UFS1B";
                    else if(fsInfoRecord.fs_type == 9)
                        fsType = "UFS2";
                    else if(fsInfoRecord.fs_type == 11)
                        fsType = "EXT2";
                    else if(fsInfoRecord.fs_type == 12)
                        fsType = "EXT3";
                    else if(fsInfoRecord.fs_type == 14)
                        fsType = "SWAP";
                    else if(fsInfoRecord.fs_type == 16)
                        fsType = "RAW";
                    else if(fsInfoRecord.fs_type == 18)
                        fsType = "ISO9660";
                    else if(fsInfoRecord.fs_type == 20)
                        fsType = "HFS";
                    else if(fsInfoRecord.fs_type == 22)
                        fsType = "EXT4";
                    else if(fsInfoRecord.fs_type == 23)
                        fsType = "YAFFS2";
                    else if(fsInfoRecord.fs_type == 25)
                        fsType = "UNSUPPORTED";
                    else
                        fsType = QString::number(fsInfoRecord.fs_type);
                    fsNode = new QStandardItem(fsType);
                    fsNode->setIcon(QIcon(":/basic/treepartition"));
                    currentFsPath = fsType + "/";
                    volNode->appendRow(fsNode);
                    //BEGIN FILE ADD CODE
                    std::vector<uint64_t> fileidVector;
                    //Create custom function to access this...
                    sqlite3* tmpImgDB;
                    QString tmpImgDbPath = wombatvariable->evidencedirpath + imagename + ".db";
                    QList<int> objectidlist;
                    objectidlist.clear();
                    if(sqlite3_open(tmpImgDbPath.toStdString().c_str(), &tmpImgDB) == SQLITE_OK)
                    {
                        sqlite3_stmt* stmt;
                        if(sqlite3_prepare_v2(tmpImgDB, "SELECT file_id FROM fs_files WHERE fs_id = ? ORDER BY file_id", -1, &stmt, 0) == SQLITE_OK)
                        {
                            if(sqlite3_bind_int(stmt, 1, fsInfoRecord.fs_id) == SQLITE_OK)
                            {
                                while(sqlite3_step(stmt) == SQLITE_ROW)
                                {
                                    uint64_t fileId = (uint64_t)sqlite3_column_int(stmt, 0);
                                    fileidVector.push_back(fileId);
                                    if(isAddEvidence == 1)
                                        objectidlist.append(wombatdata->InsertObject(wombatvariable->caseid, wombatvariable->evidenceid, (int)fileId));
                                }
                                sqlite3_finalize(stmt);
                            }
                            else
                            {
                                //std::wstringstream infoMessage;
                                //infoMessage << L"Get FsFileIds Failed: " << sqlite3_errmsg(imgdb);
                                //LOGERROR(infoMessage.c_str());
    
                            }
                        }
                        else
                        {
                            //std::wstringstream infoMessage;
                            //infoMessage << L"Get FsFileIds Failed: " << sqlite3_errmsg(imgdb);
                            //LOGERROR(infoMessage.c_str());
                        }
                    }
                    sqlite3_close(tmpImgDB);
                    //end create custom function to access fileid
                    QList<QList<QStandardItem*> > treeList;
                    foreach(tmpId, fileidVector)
                    {
                        TskFileRecord tmprecord;
                        ret = TskServices::Instance().getImgDB().getFileRecord(tmpId, tmprecord);
                        //fprintf(stderr, "%s\n", tmprecord.md5.c_str());
                        fileRecordVector.push_back(tmprecord);
                    }
                    for(int i=0; i < (int)fileRecordVector.size(); i++)
                    {
                        QStandardItem* tmpitem;
                        QList<QStandardItem*> sleuthList;
                        fullPath = imagename + "/" + currentVolPath + currentFsPath;
                        if(fileRecordVector[i].parentFileId == 0)
                        {
                            fullPath += "root/";
                            sleuthList << new QStandardItem(QString("root"));
                        }
                        else
                        {
                            fullPath += "root/" + QString(fileRecordVector[i].fullPath.c_str());
                            sleuthList << new QStandardItem(QString(fileRecordVector[i].name.c_str()));
                        }
                        tmpitem = new QStandardItem(QString::number(wombatdata->ReturnObjectID(wombatvariable->caseid, wombatvariable->evidenceid, (int)fileRecordVector[i].fileId)));
                        tmpitem->setCheckable(true);
                        sleuthList << tmpitem;
                        //sleuthList << new QStandardItem(QString::number((int)fileRecordVector[i].fileId));
                        sleuthList << new QStandardItem(fullPath);
                        sleuthList << new QStandardItem(QString::number(fileRecordVector[i].size));
                        if(sqlite3_open(tmpImgDbPath.toStdString().c_str(), &tmpImgDB) == SQLITE_OK)
                        {
                            sqlite3_stmt* stmt;
                            if(sqlite3_prepare_v2(tmpImgDB, "select value_text from blackboard_attributes where attribute_type_id = 62 and obj_id = ?;", -1, &stmt, 0) == SQLITE_OK)
                            {
                                if(sqlite3_bind_int(stmt, 1, (int)fileRecordVector[i].fileId) == SQLITE_OK)
                                {
                                    int ret = sqlite3_step(stmt);
                                    if(ret == SQLITE_ROW || ret == SQLITE_DONE)
                                    {
                                        sleuthList << new QStandardItem(QString((const char*)sqlite3_column_text(stmt, 0)));
                                    }
                                    sqlite3_finalize(stmt);
                                }
                                else
                                {
                                    //std::wstringstream infoMessage;
                                    //infoMessage << L"Get FsFileIds Failed: " << sqlite3_errmsg(imgdb);
                                    //LOGERROR(infoMessage.c_str());
                                }
                            }
                            else
                            {
                                //std::wstringstream infoMessage;
                                //infoMessage << L"Get FsFileIds Failed: " << sqlite3_errmsg(imgdb);
                                //LOGERROR(infoMessage.c_str());
                            }
                        }
                        sqlite3_close(tmpImgDB);
                        sleuthList << new QStandardItem(QString::fromStdString(getFileType(fileRecordVector[i].name.c_str())));
                        sleuthList << new QStandardItem(DisplayTimeUTC(fileRecordVector[i].crtime));
                        sleuthList << new QStandardItem(DisplayTimeUTC(fileRecordVector[i].atime));
                        sleuthList << new QStandardItem(DisplayTimeUTC(fileRecordVector[i].mtime));
                        sleuthList << new QStandardItem(DisplayTimeUTC(fileRecordVector[i].ctime));
                        sleuthList << new QStandardItem(QString(fileRecordVector[i].md5.c_str()));
                        //fprintf(stderr, "%i - %s\n", i, fileRecordVector[i].md5.c_str());
                        treeList.append(sleuthList);
                    }
                    for(int i = 0; i < (int)fileRecordVector.size(); i++)
                    {
                        // NEED TO EXPAND FOR OTHER ICONS
                        QStandardItem* tmpItem2 = ((QStandardItem*)treeList[i].first());
                        if(((TskFileRecord)fileRecordVector[i]).dirType == 3)
                        {
                            tmpItem2->setIcon(QIcon(":/basic/treefolder"));
                        }
                        else
                        {
                            tmpItem2->setIcon(QIcon(":/basic/treefile"));
                        }
                        if(((TskFileRecord)fileRecordVector[i]).parentFileId == 0)
                        {
                            fsNode->appendRow(treeList[i]);
                        }
                    }
                    for(int i=0; i < (int)fileRecordVector.size(); i++)
                    {
                        tmpRecord = fileRecordVector[i];
                        if(tmpRecord.parentFileId > 0)
                        {
                            ((QStandardItem*)treeList[tmpRecord.parentFileId-1].first())->appendRow(treeList[i]);
                        }
                    }
                    //END FILE ADD CODE
                }
            }
        }
    }
    emit ReturnImageNode(imageNode);
}

void SleuthKitPlugin::ExportFile(std::string exportpath, int objectID)
{
    int fileID = wombatdata->ReturnObjectFileID(objectID); // file id
    TskImageFileTsk currentimagefiletsk;
    try
    {
        currentimagefiletsk.open(wombatvariable->evidencepath.toStdString());
        TskServices::Instance().setImageFile(currentimagefiletsk);
    }
    catch(TskException ex)
    {
        fprintf(stderr, "Error setfile: %s\n", ex.what());
    }
    int ihandle;
    try
    {
        ihandle = TskServices::Instance().getImageFile().openFile(fileID);
        //fprintf(stderr, "getimagefile works...");
    }
    catch(TskException ex)
    {
        fprintf(stderr, "Error getFile: %s\n", ex.what());
    }
    TskFile* tfile;
    try
    {
        tfile = TskServices::Instance().getFileManager().getFile((uint64_t)fileID);
        //fprintf(stderr, "get file from image works\n");
    }
    catch(TskException ex)
    {
        fprintf(stderr, "Get File Error: %s\n", ex.what());
    }
    if(tfile->isDirectory())
    {
        bool tmpdir = (new QDir())->mkpath(QString::fromStdString(exportpath));
        if(!tmpdir)
            fprintf(stderr, "%s creation failed.\n");
        //fprintf(stderr, "need to make the directory here...\n");
    }
    else
    {
        try
        {
            if(!tfile->exists())
            {
                TskServices::Instance().getFileManager().saveFile(tfile);
            }
        }
        catch(TskException ex)
        {
            fprintf(stderr, "read file/write to fail failed %s\n", ex.what());
        }
        catch(std::exception ex)
        {
            fprintf(stderr, "read file/write to fail %s\n", ex.what());
        }
        std::wstringstream ws;
        ws << exportpath.c_str();
        std::wstring wexportpath = ws.str();
        try
        {
            TskServices::Instance().getFileManager().copyFile(tfile, wexportpath);
        }
        catch(TskException ex)
        {
            fprintf(stderr, "copy file to export location failed %s\n", ex.what());
        }
        catch(std::exception ex)
        {
            fprintf(stderr, "copy file to export location failed %s\n", ex.what());
        }
    }
}   

QStringList SleuthKitPlugin::GetVolumeContents(WombatVariable* wombatVariable)
{
    wombatvariable = wombatVariable;
    SetEvidenceDB(wombatvariable);
    std::list<TskVolumeInfoRecord> vollist;
    QStringList voldesclist;
    TskVolumeInfoRecord volrecord;
    int ret;
    vollist.clear();
    voldesclist.clear();
    ret = TskServices::Instance().getImgDB().getVolumeInfo(vollist);
    foreach(volrecord, vollist)
    {
        voldesclist << QString::fromUtf8(volrecord.description.c_str()) << QString::number(volrecord.vol_id);
    }
    return voldesclist;
}

QString SleuthKitPlugin::GetVolumeFilePath(WombatVariable* wombatVariable, int volID)
{
    wombatvariable = wombatVariable;
    sqlite3* tmpImgDB;
    int ret;
    QString tmpImgDbPath = wombatvariable->evidencedirpath + wombatvariable->evidencepath.split("/").last() + ".db";
    uint64_t secstart = -1;
    uint64_t seclength = -1;
    if(sqlite3_open(tmpImgDbPath.toStdString().c_str(), &tmpImgDB) == SQLITE_OK)
    {
        sqlite3_stmt* stmt;
        if(sqlite3_prepare_v2(tmpImgDB, "SELECT sect_start, sect_len FROM vol_info WHERE vol_id = ?", -1, &stmt, 0) == SQLITE_OK)
        {
            if(sqlite3_bind_int(stmt, 1, volID) == SQLITE_OK)
            {
                ret = sqlite3_step(stmt);
                if(ret == SQLITE_ROW || ret == SQLITE_DONE)
                {
                    secstart = sqlite3_column_int64(stmt, 0);
                    seclength = sqlite3_column_int64(stmt, 1);
                }
            }
        }
        sqlite3_finalize(stmt);
    }
    TskImageFileTsk currentimagefiletsk;
    uint64_t bytelen = 512*(seclength - 1);
    uint64_t bytestart = 512*secstart;
    char* volbuffer = NULL;
    volbuffer = new char[bytelen+512];

    try
    {
        currentimagefiletsk.open(wombatvariable->evidencepath.toStdString());
        TskServices::Instance().setImageFile(currentimagefiletsk);
    }
    catch(TskException ex)
    {
        fprintf(stderr, "Error set image file: %s\n", ex.what());
    }
    int retval = 0;
    try
    {
        // need to figure out why this fails... and returns -1
        retval = TskServices::Instance().getImageFile().getSectorData(secstart, seclength-1, volbuffer);
        fprintf(stderr, "sector data return value: %i\n", retval);
        if (retval == -1)
        {
        }
    }
    catch(TskException ex)
    {
        fprintf(stderr, "Error getting sector data: %s\n", ex.what());
    }
    if(retval > 0)
    {
        QFile tmpfile("/home/pasquale/WombatForensics/tmpfiles/volbyte.dat");
        tmpfile.open(QIODevice::WriteOnly);
        tmpfile.write(volbuffer, bytelen);
        tmpfile.close();
    }
    delete[] volbuffer;
    //delete volbuffer;

    return "/home/pasquale/WombatForensics/tmpfiles/volbyte.dat";
}

QString SleuthKitPlugin::GetFileContents(int fileID)
{
    TskImageFileTsk currentimagefiletsk;
    QString returnpath = "";
    try
    {
        currentimagefiletsk.open(wombatvariable->evidencepath.toStdString());
        TskServices::Instance().setImageFile(currentimagefiletsk);
    }
    catch(TskException ex)
    {
        fprintf(stderr, "Error setfile: %s\n", ex.what());
    }
    int ihandle;
    try
    {
        ihandle = TskServices::Instance().getImageFile().openFile(fileID);
        //fprintf(stderr, "getimagefile works...");
    }
    catch(TskException ex)
    {
        fprintf(stderr, "Error getFile: %s\n", ex.what());
    }
    TskFile* tfile;
    try
    {
        tfile = TskServices::Instance().getFileManager().getFile((uint64_t)fileID);
        //fprintf(stderr, "get file from image works\n");
    }
    catch(TskException ex)
    {
        fprintf(stderr, "Get File Error: %s\n", ex.what());
    }
    // Saves the directory data stream from the image to a tmp file
    if(tfile->isDirectory())
    {
        try
        {
            const int FILE_BUFFER_SIZE = 8192;
            QString tmpfile = QString::fromStdWString(TskServices::Instance().getFileManager().getPath((uint64_t)fileID));
            tmpfile += "dir.dat";
            Poco::File destFile(tmpfile.toStdString());
            //If the destination file exists it is replaced
            if (destFile.exists())
            {
                destFile.remove();
            }
            // We read the content from the file and write it to the target
            tfile->open();
            // Create a new empty file.
            destFile.createFile();
            // Call File.read() to get the file content and write to new file.
            Poco::FileOutputStream fos(destFile.path());
            char buffer[FILE_BUFFER_SIZE];
            int bytesRead = 0;
            // Remember the offset the file was at when we were called.
            TSK_OFF_T savedOffset = tfile->tell();
            // Reset to start of file to ensure all content is saved.
            tfile->seek(0, std::ios_base::beg);
            do
            {
                memset(buffer, 0, FILE_BUFFER_SIZE);
                bytesRead = tfile->read(buffer, FILE_BUFFER_SIZE);
                if (bytesRead > 0)
                    fos.write(buffer, bytesRead);
            }
            while (bytesRead > 0);
            // Flush and close the output stream.
            fos.flush();
            fos.close();
            // Restore the saved offset.
            tfile->seek(savedOffset, std::ios_base::beg);
            // Close the file
            tfile->close();
            returnpath = tmpfile;
        }
        catch(TskException ex)
        {
            fprintf(stderr, "dir save buffer to dir.dat file failed\n");
        }
        catch(std::exception ex)
        {
            fprintf(stderr, "dir save buffer to dir.dat file failed\n");
        }
    }
    else
    {
        try
        {
            if(!tfile->exists())
            {
                TskServices::Instance().getFileManager().saveFile(tfile);
            }
        }
        catch(TskException ex)
        {
            fprintf(stderr, "read file/write to fail failed %s\n", ex.what());
        }
        catch(std::exception ex)
        {
            fprintf(stderr, "read file/write to fail %s\n", ex.what());
        }
        int objectid = wombatdata->ReturnObjectID(wombatvariable->caseid, wombatvariable->evidenceid, fileID);
        if(objectid != (int)fileID)
        {
            QString oldfile = QString::fromStdWString(TskServices::Instance().getFileManager().getPath((uint64_t)fileID));
            QString filepath = oldfile.left(oldfile.lastIndexOf("/"));
            QString newfile = filepath + "/" + QString::number(objectid);
            QFile tmpfile(oldfile);
            if(tmpfile.rename(newfile))
            {
                //fprintf(stderr, "new file: %s\n", newfile.toStdString().c_str());
                returnpath = newfile;
            }
            else
            {
                //fprintf(stderr, "old file value: %s\n", oldfile.toStdString().c_str());
                //fprintf(stderr, "new file failed: %s\n", newfile.toStdString().c_str());
                // i'll need to return or log an error here somehow.
            }
        }
        else
        {
            returnpath = QString::fromStdWString(TskServices::Instance().getFileManager().getPath((uint64_t)fileID));
            //fprintf(stderr, "old == new: %s\n", returnpath.toStdString().c_str());
        }
    }

    return returnpath;
}
------------------------
TskLog.cpp
------------------------
/*
 * The Sleuth Kit
 *
 * Contact: Brian Carrier [carrier <at> sleuthkit [dot] org]
 * Copyright (c) 2010-2012 Basis Technology Corporation. All Rights
 * reserved.
 *
 * This software is distributed under the Common Public License 1.0
 */

#include <string.h>
#include <errno.h>
#include "string.h"
#include "TskLog.h"
#include "../utilities/TskUtilities.h"
#include "sys/stat.h"
#include <time.h>
#include <Poco/FileStream.h>
#include <Poco/Exception.h>
#include <Poco/LineEndingConverter.h>

// @@@ imports for directory creation and deletion
//#include "windows.h"

void TskLog::log(Channel msgType, const std::wstring &logMsg)
{
    log(msgType, TskUtilities::toUTF8(logMsg).c_str());
}

void TskLog::log(Channel msgType, const std::string &logMsg)
{
    //dbpath = logvariable.datapath.toStdString();
    //dbpath.append("WombatLog.db");
    //std::string dbpath = "/home/pasquale/WombatForensics/data/WombatLog.db";
    Log::log(msgType, logMsg);

    struct tm *newtime;
    time_t aclock;

    time(&aclock);   // Get time in seconds
    newtime = localtime(&aclock);   // Convert time to struct tm form 
    char timeStr[64];
    snprintf(timeStr, 64, "%.2d/%.2d/%.2d %.2d:%.2d:%.2d",
        newtime->tm_mon+1,newtime->tm_mday,newtime->tm_year % 100, 
        newtime->tm_hour, newtime->tm_min, newtime->tm_sec);

    // db log entry as follows.
    sqlite3* tmpImgDB;
    if(sqlite3_open(dbpath.c_str(), &tmpImgDB) == SQLITE_OK)
    {
        sqlite3_stmt* stmt;
        if(sqlite3_prepare_v2(tmpImgDB, "INSERT INTO log (caseid, evidenceid, jobid, msgtype, msgdatetime, msg) VALUES(?, ?, ?, ?, ?, ?);", -1, &stmt, 0) == SQLITE_OK)
        {
            if(sqlite3_bind_int(stmt, 1, logvariable.caseid) == SQLITE_OK && sqlite3_bind_int(stmt, 2, logvariable.evidenceid) == SQLITE_OK && sqlite3_bind_int(stmt, 3, logvariable.jobid) == SQLITE_OK && sqlite3_bind_int(stmt, 4, msgType) == SQLITE_OK && sqlite3_bind_text(stmt, 5, timeStr, -1, SQLITE_TRANSIENT) == SQLITE_OK && sqlite3_bind_text(stmt, 6, logMsg.c_str(), -1, SQLITE_TRANSIENT) == SQLITE_OK)
            {
                int ret = sqlite3_step(stmt);
                if(ret == SQLITE_ROW || ret == SQLITE_DONE)
                {
                }
                else
                {
                    fprintf(stderr, "Error: %s\n", sqlite3_errmsg(tmpImgDB));
                }
            }
            else
                fprintf(stderr, "Error: %s\n", sqlite3_errmsg(tmpImgDB));
        }
        else
        {
            fprintf(stderr, "Error: %s\n", sqlite3_errmsg(tmpImgDB));
        }
        sqlite3_finalize(stmt);
    }
    else
    {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(tmpImgDB));
    }
    sqlite3_close(tmpImgDB);
}
-------------------------------
old.wombatforensics.ui
-------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>WombatForensics</class>
 <widget class="QMainWindow" name="WombatForensics">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>800</width>
    <height>600</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>WombatForensics</string>
  </property>
  <widget class="QWidget" name="centralwidget">
   <layout class="QVBoxLayout" name="verticalLayout">
    <item>
     <widget class="QSplitter" name="splitter">
      <property name="orientation">
       <enum>Qt::Vertical</enum>
      </property>
      <property name="childrenCollapsible">
       <bool>false</bool>
      </property>
      <widget class="QTabWidget" name="fileViewTabWidget">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="maximumSize">
        <size>
         <width>16777215</width>
         <height>467</height>
        </size>
       </property>
      </widget>
      <widget class="QTabWidget" name="fileInfoTabWidget">
       <property name="currentIndex">
        <number>-1</number>
       </property>
      </widget>
     </widget>
    </item>
   </layout>
  </widget>
  <widget class="QMenuBar" name="mainMenubar">
   <property name="geometry">
    <rect>
     <x>0</x>
     <y>0</y>
     <width>800</width>
     <height>19</height>
    </rect>
   </property>
   <property name="acceptDrops">
    <bool>true</bool>
   </property>
   <widget class="QMenu" name="menuFile">
    <property name="title">
     <string>File</string>
    </property>
    <addaction name="actionNew_Case"/>
    <addaction name="actionOpen_Case"/>
    <addaction name="separator"/>
    <addaction name="actionView_Progress"/>
    <addaction name="separator"/>
    <addaction name="actionExit"/>
   </widget>
   <widget class="QMenu" name="menuEvidence">
    <property name="title">
     <string>Evidence</string>
    </property>
    <addaction name="actionAdd_Evidence"/>
    <addaction name="actionRemove_Evidence"/>
    <addaction name="separator"/>
   </widget>
   <widget class="QMenu" name="menuAction">
    <property name="title">
     <string>Action</string>
    </property>
    <addaction name="actionExport_Evidence"/>
   </widget>
   <widget class="QMenu" name="menuSettings">
    <property name="title">
     <string>Settings</string>
    </property>
    <addaction name="actionManage_OmniViewer"/>
   </widget>
   <addaction name="menuFile"/>
   <addaction name="menuEvidence"/>
   <addaction name="menuAction"/>
   <addaction name="menuSettings"/>
  </widget>
  <widget class="QStatusBar" name="mainStatusbar"/>
  <widget class="QToolBar" name="mainToolBar">
   <property name="windowTitle">
    <string>toolBar</string>
   </property>
   <property name="movable">
    <bool>false</bool>
   </property>
   <property name="allowedAreas">
    <set>Qt::TopToolBarArea</set>
   </property>
   <property name="floatable">
    <bool>false</bool>
   </property>
   <attribute name="toolBarArea">
    <enum>TopToolBarArea</enum>
   </attribute>
   <attribute name="toolBarBreak">
    <bool>false</bool>
   </attribute>
   <addaction name="actionNew_Case"/>
   <addaction name="actionOpen_Case"/>
   <addaction name="separator"/>
   <addaction name="actionView_Progress"/>
   <addaction name="separator"/>
   <addaction name="actionAdd_Evidence"/>
   <addaction name="actionRemove_Evidence"/>
   <addaction name="separator"/>
   <addaction name="actionExport_Evidence"/>
  </widget>
  <action name="actionNew_Case">
   <property name="icon">
    <iconset>
     <normaloff>:/newcase</normaloff>:/newcase</iconset>
   </property>
   <property name="text">
    <string>New Case</string>
   </property>
  </action>
  <action name="actionOpen_Case">
   <property name="icon">
    <iconset>
     <normaloff>:/opencase</normaloff>:/opencase</iconset>
   </property>
   <property name="text">
    <string>Open Case</string>
   </property>
  </action>
  <action name="actionView_Progress">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="icon">
    <iconset>
     <normaloff>:/progresswindow/window</normaloff>:/progresswindow/window</iconset>
   </property>
   <property name="text">
    <string>View Progress...</string>
   </property>
  </action>
  <action name="actionExit">
   <property name="text">
    <string>Exit</string>
   </property>
  </action>
  <action name="actionAdd_Evidence">
   <property name="icon">
    <iconset>
     <normaloff>:/basic/addevidence</normaloff>:/basic/addevidence</iconset>
   </property>
   <property name="text">
    <string>Add Evidence</string>
   </property>
  </action>
  <action name="actionRemove_Evidence">
   <property name="icon">
    <iconset>
     <normaloff>:/basic/remevidence</normaloff>:/basic/remevidence</iconset>
   </property>
   <property name="text">
    <string>Remove Evidence</string>
   </property>
  </action>
  <action name="actionExport_Evidence">
   <property name="icon">
    <iconset>
     <normaloff>:/basic/export</normaloff>:/basic/export</iconset>
   </property>
   <property name="text">
    <string>Export Evidence</string>
   </property>
  </action>
  <action name="actionManage_OmniViewer">
   <property name="text">
    <string>Manage OmniViewer</string>
   </property>
  </action>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>actionExit</sender>
   <signal>triggered()</signal>
   <receiver>WombatForensics</receiver>
   <slot>close()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>-1</x>
     <y>-1</y>
    </hint>
    <hint type="destinationlabel">
     <x>399</x>
     <y>299</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>actionAdd_Evidence</sender>
   <signal>triggered()</signal>
   <receiver>WombatForensics</receiver>
   <slot>AddEvidence()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>-1</x>
     <y>-1</y>
    </hint>
    <hint type="destinationlabel">
     <x>20</x>
     <y>20</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>actionRemove_Evidence</sender>
   <signal>triggered()</signal>
   <receiver>WombatForensics</receiver>
   <slot>RemEvidence()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>-1</x>
     <y>-1</y>
    </hint>
    <hint type="destinationlabel">
     <x>20</x>
     <y>20</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>actionExport_Evidence</sender>
   <signal>triggered()</signal>
   <receiver>WombatForensics</receiver>
   <slot>ExportEvidence()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>-1</x>
     <y>-1</y>
    </hint>
    <hint type="destinationlabel">
     <x>20</x>
     <y>20</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>
----------------------------

----------------------------
